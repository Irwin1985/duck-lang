; ** Duck Syntax **
; ** Version 0.2.17.5.15 **
;
; top level program
<program> ::= <stmtlist>
<stmtlist> ::= <stmt> <stmtlist>
<stmtlist> ::= <epsilon>
<optendl> ::= <endl>
<optendl> ::= <epsilon>
<identifier-list> ::= <identifier> , <identifier-list>
<identifier-list> ::= <identifier>
;
; program statements
<stmt> ::= import <identifier-list> <endl>
<stmt> ::= include <string> <endl>
<stmt> ::= <assignment> <endl>
<stmt> ::= <self-assignment> <endl>
<stmt> ::= <function> <endl>
<stmt> ::= <if> <endl>
<stmt> ::= <for> <endl>
<stmt> ::= <while> <endl>
<stmt> ::= <try-block> <endl>
<stmt> ::= <class> <endl>
<stmt> ::= return <endl>
<stmt> ::= return <expr> <endl>
<stmt> ::= continue <endl>
<stmt> ::= break <endl>
<stmt> ::= throw <expr> <endl>
<stmt> ::= <expr> <endl>
<stmt> ::= <endl>
;
; class structure
<class> ::= class <identifier> <endl> <class-body>
<class> ::= class <identifier> extends <identifier-list> <endl> <class-body>
<class-body> ::= <class-stmtlist> endclass
<class-stmtlist> ::= <class-stmt> <class-stmtlist>
<class-stmtlist> ::= <epsilon>
<class-stmt> ::= static <assignment> <endl>
<class-stmt> ::= static <function> <endl>
<class-stmt> ::= <assignment> <endl>
<class-stmt> ::= <function> <endl>
<class-stmt> ::= <endl>
;
; function definitions
<function> ::= func <identifier> <function-def>
<function> ::= func <string> <function-def>
<function-def> ::= <parameters> <endl> <stmtlist> endfunc
;
; function definition parameters
<parameters> ::= ( <identifier-list> )
<parameters> ::= ( )
<parameters> ::= <epsilon>
;
; function call arguments
<arguments> ::= <epsilon>
<arguments> ::= <expr-list>
<expr-list> ::= <expr> , <expr-list>
<expr-list> ::= <expr>
;
; if conditions
<if> ::= if <condition> then <endl> <stmtlist> <elseif>
<elseif> ::= else <endl> <stmtlist> endif
<elseif> ::= else <if>
<elseif> ::= endif
;
; for-to and for-in loops
<for> ::= for <identifier> <for-start>
<for-start> ::= = <arithmetic> to <arithmetic> do <endl> <loop-end>
<for-start> ::= = <arithmetic> to <arithmetic> step <arithmetic> do <endl> <loop-end>
<for-start> ::= in <final> do <endl> <loop-end>
;
; while and do-while loops
<while> ::= while <condition> do <endl> <loop-end>
<while> ::= do <endl> <stmtlist> loop while <condition> 
<loop-end> ::= <stmtlist> loop
;
; try exception catching blocks
<try-block> ::= try <endl> <stmtlist> <catch-block>
<catch-block> ::= catch <l-value> <endl> <stmtlist> done
<catch-block> ::= done
;
; assignment statements
<assignment> ::= <l-value> = <expr>
<assignment> ::= <l-value> = <object>
<self-assignment> ::= <l-value> += <arithmetic>
<self-assignment> ::= <l-value> -= <arithmetic>
<self-assignment> ::= <l-value> *= <arithmetic>
<self-assignment> ::= <l-value> /= <arithmetic>
<self-assignment> ::= <l-value> ++
<self-assignment> ::= <l-value> --
;
; l-value, assignables
<l-value> ::= <identifier>
<l-value> ::= <l-value> [ <arithmetic> ]
<l-value> ::= <l-value> . <identifier>
;
; associative arithmetic and logic
<expr> ::= <condition>
<condition> ::= <condition> and <logic>
<condition> ::= <condition> or <logic>
<condition> ::= <logic>
<logic> ::= not <comparison>
<logic> ::= <comparison>
<comparison> ::= <comparison> == <arithmetic>
<comparison> ::= <comparison> != <arithmetic>
<comparison> ::= <comparison> \< <arithmetic>
<comparison> ::= <comparison> > <arithmetic>
<comparison> ::= <comparison> \<= <arithmetic>
<comparison> ::= <comparison> >= <arithmetic>
<comparison> ::= <final> is <l-value>
<comparison> ::= <final> is not <l-value>
<comparison> ::= <arithmetic>
<arithmetic> ::= <arithmetic> + <term>
<arithmetic> ::= <arithmetic> - <term>
<arithmetic> ::= <term>
<term> ::= <term> * <factor>
<term> ::= <term> / <factor>
<term> ::= <term> mod <factor>
<term> ::= <factor>
<factor> ::= - <value>
<factor> ::= ! <value>
<factor> ::= <value>
;
; basic value
<value> ::= <primitive>
<value> ::= <l-value>
<value> ::= <l-value> ( <arguments> )
<value> ::= new <l-value> ( <arguments> )
<value> ::= ( <expr> )
;;;; <value> ::= <object> ; no inline objects
;
; primitive values
<primitive> ::= true
<primitive> ::= false
<primitive> ::= <integer>
<primitive> ::= <float>
<primitive> ::= <string>
;
; object initializers
<object> ::= [ <optendl> ]
<object> ::= [ <optendl> <array-init>
<object> ::= [ <optendl> <dictionary-init>
;
; arrays
<array-init> ::= <expr> , <optendl> <array-init>
<array-init> ::= <expr> <optendl> ]
;
; objects
<dictionary-init> ::= <dictionary-entry> , <optendl> <dictionary-init>
<dictionary-init> ::= <dictionary-entry> ]
<dictionary-entry> :: = <identifier> : <optendl> <expr>


/*
    variable length array
*/

typedef struct {
    char* data;
    int   blockSize;
    int   blocks;
    int   length;
} VARRAY;

void  varrayAlloc(VARRAY* array, int blockSize)
{
    array->data = NULL;
    array->blockSize = blockSize;
    array->blocks = 0;
    array->length = 0;
}

void  varrayFree(VARRAY* array)
{
    if (array) 
    {
        free(array->data);
        array->data = NULL;
        array->blocks = 0;
        array->length = 0;
    }
}

void  varrayExpand(VARRAY* array, int size)
{
    size = 2 * size + 1;
    if (size > array->blocks) 
    {
        int i;
        char* newArray = malloc(size * array->blockSize);
        for (i = 0; i < array->blocks * array->blockSize; i++) 
        {
            newArray[i] = array->data[i];
        }
        
        free(array->data);
        array->data = newArray;
        array->blocks = size;
    }
}

void* varrayAccess(VARRAY* array, int index)
{
    if (array)
    {
        if (index >= array->blocks) {
            varrayExpand(array, index);
        }
        array->length = index > array->length ? index : array->length;
        return (array->data + index * array->blockSize);
    }
    return NULL;
}

/*
    priority queue
*/

typedef struct {
    int   size;
    int*  priorities;
    void* data;
    int   length;
} PRIORITY_Q;

void pqAlloc(PRIORITY_Q* queue, int count)
{
    queue->size = count;
    queue->priorities = malloc(sizeof(int) * count);
    queue->data = malloc(sizeof(void*) * count);
    queue->length = 0;
}

void pqFree(PRIORITY_Q* queue)
{
    free(queue->priorities);
    free(queue->data);
    queue->priorities = NULL;
    queue->data = NULL;
    queue->size = 0;
    queue->length = 0;
}

void pqPush(PRIORITY_Q* queue, int priority, void* element)
{
    if (queue->length < queue->size) 
    {
        int index = queue->length;
        queue->priorities[index] = priority;
        queue->data[index] = element;
        queue->length++;
        
        while (index && 
               queue->priorities[index] < queue->priorities[(index-1)/2])
        {
            priority = queue->priorities[index];
            queue->priorities[index] = queue->priorities[(index-1)/2];
            queue->priorities[(index-1)/2] = priority;
            element = queue->data[index];
            queue->data[index] = queue->data[(index-1)/2];
            queue->data[(index-1)/2] = element;
            
            index = (index-1)/2;
        }
    }
}

void* pqPeak(PRIORITY_Q* queue)
{
    if (queue->length)
        return queue->data[0];
    return NULL;
}

void* pqPop(PRIORITY_Q* queue)
{
    if (queue->length)
    {
        int index;
        void* value = queue->data[0];
        queue->length--;
        queue->priority[0] = queue->priority[queue->length];        
        queue->data[0] = queue->data[queue->length];
        
        index = 0;
        while (index < queue->length &&
               (queue->priority[index] > queue->priority[2*index+1] ||
                queue->priority[index] > queue->priority[2*index+2]))
        {
            // swap
        }
    }
    return NULL;
}


/*
    heap sort
*/

// push push push push ... pop pop pop pop

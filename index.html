<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Duck Programming Language Official Website</title>
    <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
    <link rel="stylesheet" href="stylesheets/styles.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    
    <!-- Dynamic Duck Example -->
    <script src="terminal/grammar.js"></script>
    <script src="terminal/lexer.js"></script>
    <script src="terminal/tables.js"></script>
    <script src="terminal/parser.js"></script>
    <script src="terminal/duck.js"></script>
    <script src="terminal/arithmetic.js"></script>
    <script src="terminal/stdduck.js"></script>
    <script src="terminal/terminal.js"></script>
    
<style>
.pl-c{color:#969896}.pl-c1,.pl-s .pl-v{color:#0086b3}.pl-e,.pl-en{color:#795da3}.pl-s .pl-s1,.pl-smi{color:#333}.pl-ent{color:#63a35c}.pl-k{color:#a71d5d}.pl-pds,.pl-s,.pl-s .pl-pse .pl-s1,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre{color:#183691}.pl-v{color:#ed6a43}.pl-id{color:#b52a1d}.pl-ii{background-color:#b52a1d;color:#f8f8f8}.pl-sr .pl-cce{color:#63a35c;font-weight:bold}.pl-ml{color:#693a17}.pl-mh,.pl-mh .pl-en,.pl-ms{color:#1d3e81;font-weight:bold}.pl-mq{color:#008080}.pl-mi{color:#333;font-style:italic}
.pl-mb{color:#333;font-weight:bold}.pl-md{background-color:#ffecec;color:#bd2c00}.pl-mi1{background-color:#eaffea;color:#55a532}.pl-mdr{color:#795da3;font-weight:bold}.pl-mo{color:#1d3e81}

#terminal {
  font-family:  Courier, Courier New, 
    Lucida Console, Terminal, Monospace;
  font-weight: normal;
  font-size: 16px;
  color: white;
  background: black;
  display: block;
  height: 300px;
  margin:0 0 20px;
  padding:8px 15px;
  word-wrap: break-word;
  white-space: pre-wrap;
  border-radius: 5px;
  overflow: auto;
  line-height: 110%;
}

.tc {
    font-weight: normal;
    font-family:  Courier, Courier New, Lucida Console, Terminal, Monospace;
    margin: 0;
    padding: 0;
    display: inline;
    word-wrap: break-word;
    white-space: pre-wrap;
    background: black;
    color: white;
    line-height: 100%;
    border: 0;
    border-radius: 0;
    font-size: inherit;
}

#cursor {
    color: white;
    background: black;
    border: 0;
    border-radius: 0;
    line-height: 100%;
    font-weight: normal;
    font-size: inherit;
}

#click-enable {
    margin-top: 140px;
    text-align: center;
}

#latest-release
{
	background-color: #6cc644;
	color: white;
	border-radius: 2px;
	text-align: center;
	padding: 5px 10px;
	font-weight: bold;
	font-size: 14px;
	margin-top: 10px;
	margin-bottom: 10px;
}

</style>
<script>
<!-- Syntax Highlighting -->
var symbols = [",", "=", "(", ")", "[", "]", "+", "-", "*", "/", ".", "==", "!=", "<", ">", "<=", ">=", "!", "{", "}", ":"];
var keywords = ["import", "include", "return", "break", "continue", "throw", "function", "end", "if", "then", "else", "for", "to", "do", "loop", "step", "in", "while", "let", "begin", "try", "complete", "catch", "object", "static", "operator", "this", "and", "or", "not", "is", "mod", "new", "true", "false", "int", "String", "global", "void", "VALUE"];
var stylized = false;
function Stylize()
{
  var lastKeyword = "";
  var inDict = false;
  var dictCount = 0;
  var c = document.getElementsByTagName("code");
  var firstChar;
  for (var s = 0; s < c.length; s++)
  {
    var t = c[s].innerHTML;
    var d = "";
    
    t = t.replace(/&lt;/g, "<");
    t = t.replace(/&gt;/g, ">");

    if (t.length > 0) firstChar = t.charAt(0);
    for (var q = 0; q < t.length; q++)
    { // lexer / keyword recognizer
      var x = t.charAt(q);
      // whitespace
      if (x == " " || x == "\r" || x == "\t" || x == "\n")
      {
        d += x;
        if (x == "\n" && q < t.length + 1)
          firstChar = t.charAt(q+1);
      }
      // strings
      else if (x == "\"" || x == "\'")
      {
        var m = x;
        d += "<span class=\"pl-s\">";
        do {
          d += x;
          q++;
          if (q >= t.length) break;
          x = t.charAt(q);
        } while (x != m);
        if (q < t.length) d += x;
        d += "</span>";
      }
      // comments
      else if (x == ";")
      {
        d += "<span class=\"pl-c\">";
        do {
          d += x;
          q++;
          if (q >= t.length) break;
          x = t.charAt(q);
        } while (x != "\n");
        d += "</span>";
        q--;
      }
      // block comments
      else if (q < t.length +1 &&
               x == "/" && t.charAt(q+1) == "*")
      {
        d += "<span class=\"pl-c\">";
        do {
          x = t.charAt(q);
          d += x;
          q++;
        } while (q < t.length + 1 &&
                 !(t.charAt(q) == "*" &&
                   t.charAt(q+1) == "/"));
        if (q < t.length + 1)
        {
          d += t.charAt(q++);
          d += t.charAt(q);
        }
        
        d += "</span>";
      }
      else if (q < t.length +1 &&
               x == "/" && t.charAt(q+1) == "/" ||
               x == "#")
      {
        d += "<span class=\"pl-c\">";
        do {
          x = t.charAt(q);
          d += x;
          q++;
        } while (q < t.length && !(t.charAt(q) == '\n'));
        d += "</span>"
        q--;
      }
      // characters
      else if (x.toLowerCase() != x.toUpperCase())
      {
        var n = "";
        do {
          n += x;
          q++;
          if (q >= t.length) break;
          x = t.charAt(q);
        } while ((x.toLowerCase() != x.toUpperCase()) ||
                 x == "_" ||
                 (x.charCodeAt(0) >= "0".charCodeAt(0) &&
                  x.charCodeAt(0) <= "9".charCodeAt(0)));
        q--;
        
        var j;
        // keyword
        for (j = 0; j < keywords.length; j++)
        {
          if (keywords[j] == n)
          {
            if (firstChar == "<")
              d += "<span class=\"pl-en\">";
            else
              d += "<span class=\"pl-k\">";
            d += n;
            d += "</span>";
            lastKeyword = n;
            break;
          }
        }
        
        // identifier
        if (j == keywords.length) {
          if (lastKeyword == "function" ||
              (inDict && dictCount % 2 == 0))
          {
            d += "<span class=\"pl-en\">";
          } else {
            d += "<span class=\"pl-c1\">";
          }
          d += n;
          d += "</span>";
          
          lastKeyword = "";
        }
      }
      // numbers
      else if (x.charCodeAt(0) >= "0".charCodeAt(0) &&
               x.charCodeAt(0) <= "9".charCodeAt(0))
      {
        d += "<span class=\"pl-c1\">"
        d += x;
        q++;
        while (q < t.length && 
            (t.charCodeAt(q) >= "0".charCodeAt(0) &&
             t.charCodeAt(q) <= "9".charCodeAt(0)))
        {
          d += t.charAt(q);
          q++;
        }
        d += "</span>";
        q--;
      }
      // grammar symbols
      else if (x == "<" && firstChar == "<")
      {
        d += "<span class=\"pl-c1\">";
        d += "&lt;";
        q++;
        while (q < t.length && t.charAt(q) != ">") {
          d += t.charAt(q);
          q++;
        }
        d += "&gt;";
        d += "</span>";
      }
      // BNF sign ::=
      else if (x == ":" && q < t.length+2 &&
               t.charAt(q+1) == ":" && t.charAt(q+2) == "=")
      {
        d += "<span class=\"pl-mb\">::=</span>";
        q += 2;
      }
      // symbols
      else {
        if (x == "{") { inDict = true; dictCount = 0; }
        if (x == "}") { inDict = false; }
        if (x == ":") { dictCount++; }
        if (x == ",") { dictCount++; }
        
        if (firstChar != ",")
          d += "<span class=\"pl-k\">";
        else
          d += "<span class=\"pl-c1\">";
        
        if (x != "<" && x != ">")
          d += x;
        else if (x == "<")
          d += "&lt;";
        else
          d += "&gt;";
          
        d += "</span>";
      }
    }
  
    c[s].innerHTML = d;
  }
}

MOTDWelcome = "Welcome to the Duck programming language interactive interpreter! " +
              "This virtual terminal will allow you to test your Duck programs.";

var started = false;
function StartConsole()
{
    if (!started)
    {
        document.getElementById("prev-output").innerHTML = "";
        started = true;
        Start();
    }
}

<!-- Start Up -->
function launch()
{
  if (stylized == false)
  {
    Stylize();
    stylized = true;
  }
  //Start();
}

</script>
  </head>
  <body onLoad="launch()">
    <div class="wrapper">
      <header>
        <h1>DuckLang.org</h1>
        <p>The Duck Programming Language official homepage</p>
        <img src="1081737.png"><br>

        <p class="view"><a href="https://github.com/gregtour/duck-lang">View the Project on GitHub <small>gregtour/duck-lang</small></a></p>


        <ul>
          <li><a href="https://github.com/gregtour/duck-lang/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/gregtour/duck-lang/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/gregtour/duck-lang">View On <strong>GitHub</strong></a></li>
        </ul>
        
        <div id="latest-release"><a href="https://github.com/gregtour/duck-lang/releases/latest">Latest Release</a></a></div>
        
        <p>This project is maintained by <br><a href="https://github.com/gregtour">Greg Tourville</a></p>
        <p><small>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></small></p>
      </header>
      <section>
        <h1>
<a id="duck-programming-language" class="anchor" href="#duck-programming-language" aria-hidden="true"><span class="octicon octicon-link"></span></a>Duck Programming Language</h1>

<p>A simple scripting language based on the idea of duck-typing (or dynamic typing).</p>

<blockquote>
<p>“When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck.”
— James Whitcomb Riley</p>
</blockquote>

<h2>
<a id="language-features" class="anchor" href="#language-features" aria-hidden="true"><span class="octicon octicon-link"></span></a>Language Features</h2>

<p>The duck programming language supports first-class functions, integer and floating-point arithmetic, string manipulation, dynamically-sized arrays, dictionary types, and basic object oriented programming. The syntax is strongly reminiscent of BASIC, Lua, or Python. While indentation is not strictly specified, the language does require specific whitespace in required newlines at the end of certain statements. Duck is currently only implemented in the form of a slow, interpreted frontend, making it useful strictly as a scripting language. This frontend has been developed entirely in C code.</p>

<p>The syntax of loops is somewhat different than in BASIC or other languages. For example, a while loop has the following syntax:</p>

<pre><code>while condition do
    // loop body
    // ...
loop
</code></pre>

<p>while a for loop in Duck looks like this</p>

<pre><code>for i = 1 to 10 do
    // iterated instructions
    // ...
    // ...
loop
</code></pre>

<p>Notice the use of the syntax `do' and `loop.'  There are a number of other example programs in the <em>examples</em> directory of the source repository.</p>

<p>The programming language's grammar is defined in deterministic context-free Backas-Naur form, viewable <a href="http://ducklang.org/syntax.html">here</a>. The duck language has its own parser-generator, generating SLR(1) parse tables, so it is relatively easy to change the syntax of the language. Other optional ways to configure the language include disabling case-sensitivity or changing the format of comments, which are currently implemented as <code>/* C-style block comments */</code>, <code>// full line comments</code>, <code>; semicolon until end of line comments</code>, and <code># any macro use</code>.</p>

<p>As an example of what a typical program might look like written in Duck, the following is an example of computing prime numbers.</p>

<pre><code>function display_primes(limit)
	count = 0
	numbers = []
	for i = 2 to limit do
		numbers[i] = 1
	loop
	for i = 2 to limit do
		if numbers[i] == 1 then
			count = count + 1
			for j = 2 to limit/i do
				numbers[i*j] = 0
			loop
			duck.println(i)
		end
	loop
end
</code></pre>


<a id="demo" class="anchor" href="#demo" aria-hidden="true"><span class="octicon octicon-link"></span></a><h2>Demo</h2>

<p>This is a virtual console running the Duck interpreter.</p>

<div id="terminal" onClick="StartConsole();"><pre class="tc" id="prev-output"><div id="click-enable">Click to Enable.</div></pre><pre class="tc" id="pre-text"></pre><span id="cursor" class="tc">&nbsp;</span><pre class="tc" id="post-text"></pre></div>


<p> Additionally, there is a less interactive scratchpad for programming <a href="http://ducklang.org/demo">here</a> and a larger version of this console app <a href="http://ducklang.org/terminal/">here</a> although the recommended way to develop using duck is to download the runtime executable.</p>


<a id="libraries" class="anchor" href="#libraries" aria-hidden="true"><span class="octicon octicon-link"></span></a><h2>Libraries</h2>

<p>It is easy to port libraries to Duck. Function hooks are implemented as pointers, of the form <code>int (function_pointer)(int)</code> where the argument count is passed as the only parameter. Arguments are bound as string identifiers, and are accessed dynamically in the bound-function's body.</p>

<p>Example:</p>

<pre><code>void BindStandardLibrary()
{
    VALUE duckStdLib = LinkNamespace("duck");

    VALUE print = CreateFunction(DuckPrint);
    AddParameter(print, "output");

    LinkFunction(duckStdLib, "print", print);
    LinkFunction(duckStdLib, "println", print);

    VALUE prompt = CreateFunction(DuckPrompt);
    LinkFunction(duckStdLib, "prompt", prompt);
}</code></pre>

<h2>
<a id="standard-library" class="anchor" href="#standard-library" aria-hidden="true"><span class="octicon octicon-link"></span></a>Standard Library</h2>

<p>Duck has a standard library supporting both command-line input and output. See: stdduck.h.
There are also SDL and OpenGL bindings to support graphical windowed programming.</p>

<p>Here is a list of those functions:</p>

<h4>
<a id="library" class="anchor" href="#library" aria-hidden="true"><span class="octicon octicon-link"></span></a>Library</h4>

<h5>
<a id="duck" class="anchor" href="#duck" aria-hidden="true"><span class="octicon octicon-link"></span></a>Duck</h5>

<ul>
<li>duck.print(output)</li>
<li>duck.println(output)</li>
<li>duck.prompt()</li>
</ul>

<h5>
<a id="sdl" class="anchor" href="#sdl" aria-hidden="true"><span class="octicon octicon-link"></span></a>SDL</h5>

<ul>
<li>SDL.MakeWindow(width, height, title, [fullscreen])</li>
<li>SDL.flip()</li>
<li>SDL.event()</li>
<li>SDL.clearScreen()</li>
<li>SDL.running()</li>
<li>SDL.waitkey()</li>
<li>SDL.quit()</li>
</ul>

<h5>
<a id="gl" class="anchor" href="#gl" aria-hidden="true"><span class="octicon octicon-link"></span></a>GL</h5>

<ul>
<li>SDL.glLoadIdentity()</li>
<li>SDL.glTranslatef(x, y, z)</li>
<li>SDL.glRotatef(deg, x, y, z)</li>
<li>SDL.glScalef(x, y, z)</li>
<li>SDL.glBegin(primitive)</li>
<li>SDL.glColor3f(r, g, b)</li>
<li>SDL.glVertex3f(x, y, z)</li>
<li>SDL.glNormal3f(x, y, z)</li>
<li>SDL.glEnd()</li>
</ul>

<h2>
<a id="building" class="anchor" href="#building" aria-hidden="true"><span class="octicon octicon-link"></span></a>Building</h2>

<p>Duck uses CMake 2.8. To build simply run:</p>

<!--<pre><code>&gt; cmake .
&gt; make
</code></pre>-->
<div class="highlight highlight-c"><pre>&gt; cmake .
&gt; make
</pre></div>

<p>Building gduck with SDL support requires SDL and OpenGL libraries. There are no platform specific libraries.</p>


<h2>Language Spec</h2>

<pre><code>; duck programming language
&lt;program&gt; ::= &lt;stmt list&gt;
&lt;stmt list&gt; ::= &lt;stmt&gt; &lt;stmt list&gt;
&lt;stmt list&gt; ::= &lt;epsilon&gt;
&lt;stmt&gt; ::= import &lt;identifier&gt; &lt;endl&gt;
&lt;stmt&gt; ::= &lt;endl&gt;
&lt;stmt&gt; ::= &lt;expr&gt; &lt;endl&gt;
&lt;stmt&gt; ::= &lt;assignment&gt; &lt;endl&gt;
&lt;stmt&gt; ::= &lt;function def&gt; &lt;endl&gt;
&lt;stmt&gt; ::= &lt;if&gt; &lt;endl&gt;
&lt;stmt&gt; ::= &lt;for loop&gt; &lt;endl&gt;
&lt;stmt&gt; ::= &lt;while loop&gt; &lt;endl&gt;
&lt;stmt&gt; ::= return &lt;expr&gt; &lt;endl&gt;
&lt;stmt&gt; ::= break &lt;endl&gt;
&lt;stmt&gt; ::= continue &lt;endl&gt;
&lt;function def&gt; ::= function &lt;identifier&gt; &lt;parameters&gt; &lt;endl&gt; &lt;stmt list&gt; end
&lt;parameters&gt; ::= &lt;epsilon&gt;
&lt;parameters&gt; ::= ( )
&lt;parameters&gt; ::= (&lt;param decl&gt;)
&lt;param decl&gt; ::= &lt;identifier&gt;
&lt;param decl&gt; ::= &lt;param decl&gt;, &lt;identifier&gt;
&lt;if&gt; ::= if &lt;condition&gt; then &lt;endl&gt; &lt;stmt list&gt; &lt;else if&gt;
&lt;else if&gt; ::= else &lt;endl&gt; &lt;stmt list&gt; end
&lt;else if&gt; ::= else &lt;if&gt;
&lt;else if&gt; ::= end
&lt;for loop&gt; ::= for &lt;identifier&gt; = &lt;arithmetic&gt; to &lt;arithmetic&gt; do &lt;endl&gt; &lt;stmt list&gt; loop
&lt;while loop&gt; ::= while &lt;condition&gt; do &lt;endl&gt; &lt;stmt list&gt; loop
&lt;assignment&gt; ::= &lt;l-value&gt; = &lt;assignment&gt;
&lt;assignment&gt; ::= &lt;l-value&gt; = &lt;condition&gt;
&lt;l-value&gt; ::= &lt;identifier&gt;
&lt;l-value&gt; ::= ( &lt;l-value&gt; )
&lt;l-value&gt; ::= &lt;reference&gt; . &lt;identifier&gt;
&lt;l-value&gt; ::= &lt;reference&gt; [ &lt;expr&gt; ]
&lt;expr&gt; ::= &lt;condition&gt;
&lt;condition&gt; ::= &lt;condition&gt; and &lt;logic&gt;
&lt;condition&gt; ::= &lt;condition&gt; or &lt;logic&gt;
&lt;condition&gt; ::= &lt;logic&gt;
&lt;logic&gt; ::= not &lt;comparison&gt;
&lt;logic&gt; ::= &lt;comparison&gt;
&lt;comparison&gt; ::= &lt;comparison&gt; == &lt;arithmetic&gt;
&lt;comparison&gt; ::= &lt;comparison&gt; != &lt;arithmetic&gt;
&lt;comparison&gt; ::= &lt;comparison&gt; \&lt; &lt;arithmetic&gt;
&lt;comparison&gt; ::= &lt;comparison&gt; &gt; &lt;arithmetic&gt;
&lt;comparison&gt; ::= &lt;comparison&gt; \&lt;= &lt;arithmetic&gt;
&lt;comparison&gt; ::= &lt;comparison&gt; &gt;= &lt;arithmetic&gt;
&lt;comparison&gt; ::= &lt;arithmetic&gt;
&lt;arithmetic&gt; ::= &lt;arithmetic&gt; + &lt;term&gt;
&lt;arithmetic&gt; ::= &lt;arithmetic&gt; - &lt;term&gt;
&lt;arithmetic&gt; ::= &lt;term&gt;
&lt;term&gt; ::= &lt;term&gt; * &lt;factor&gt;
&lt;term&gt; ::= &lt;term&gt; / &lt;factor&gt;
&lt;term&gt; ::= &lt;factor&gt;
&lt;factor&gt; ::= -&lt;factor&gt;
&lt;factor&gt; ::= !&lt;factor&gt;
&lt;factor&gt; ::= &lt;final&gt;
&lt;final&gt; ::= ( &lt;expr&gt; )
&lt;final&gt; ::= &lt;boolean&gt;
&lt;final&gt; ::= &lt;integer&gt;
&lt;final&gt; ::= &lt;float&gt;
&lt;final&gt; ::= &lt;string&gt;
&lt;final&gt; ::= &lt;object&gt;
&lt;final&gt; ::= &lt;reference&gt;
&lt;reference&gt; ::= &lt;l-value&gt;
&lt;reference&gt; ::= &lt;reference&gt; ( )
&lt;reference&gt; ::= &lt;reference&gt; ( &lt;arguments&gt; )
&lt;arguments&gt; ::= &lt;arguments&gt;, &lt;expr&gt;
&lt;arguments&gt; ::= &lt;expr&gt;
&lt;object&gt; ::= [ ]
&lt;object&gt; ::= [ &lt;array init&gt; ]
&lt;object&gt; ::= [ &lt;dictionary init&gt; ]
&lt;array init&gt; ::= &lt;array init&gt;, &lt;expr&gt;
&lt;array init&gt; ::= &lt;expr&gt;
&lt;dictionary init&gt; ::= &lt;dictionary init&gt;, &lt;identifier&gt; : &lt;expr&gt;
&lt;dictionary init&gt; ::= &lt;identifier&gt; : &lt;expr&gt;
&lt;boolean&gt; ::= true
&lt;boolean&gt; ::= false
</pre></code>

<h2>
<a id="credits" class="anchor" href="#credits" aria-hidden="true"><span class="octicon octicon-link"></span></a>Credits</h2>

<p>Greg Tourville - <a href="http://team-duck.com">Team Duck</a><br>
Hiroyuki Sano  <br>
Robert Cope</p>



<h2>
<a id="future-work" class="anchor" href="#future-work" aria-hidden="true"><span class="octicon octicon-link"></span></a>Future Work</h2>

<ul>
<li>Benchmark and profiling performance intrinsics</li>
<li>Expanding the standard library</li>
</ul>
      </section>
      <footer>
      </footer>
    </div>
    <script src="javascripts/scale.fix.js"></script>
    
  </body>
</html>
